MEMO

# DB Migration 

local to docker container
docker container to local


migrate create -ext sql -dir db/migration -seq init_schema
-seq means migrate version name.

migrate -path db/migration -database "postgres://root:secret@localhost:5432/simple_bank?sslmode=disable" -verbose up


brew install postgresql
brew install tableplus
brew install sqlc // sql to go 

# pq - A pure Go postgres driver for Go's database/sql package
go get github.com/lib/pq
go get github.com/stretchr/testify
                                  /require

# CRUD sqlc

move to root directory
 -> command "sqlc init"
 -> set sqlc.yaml file
 -> command "sqlc generate"


# Unit tests

When writing Unit tests,
Should make sure that they are independent from each other.
Why: hard to maintain if has hundred of tests that depends on each other.

# Transaction

DB Transaction

Why?
1. To provide a reliable and consistent unit of work, even in case of system failure.
2. To provide isolation between programs that access the database concurrently.

A: Atomicity
C: Consistency
I: Isolation
D: Durability

Closure is often used when want to get the result from a callback function.
the callback function itself doesn't know the exact type of the result it should return

# Caution when Database Transaction
concurrency carefully!
The best way that is run it with several concurrent go routines

# Update Account within Transaction
Require careful handing of concurrent transactions to avoid deadlock
database locking 

# TDD | test driven development
Tests first to make our current code breaks

# Deadlock postgresql
https://wiki.postgresql.org/wiki/Lock_Monitoring
Deadlock ocuurs because 2 concurrent transactions both need to wait for each other

can resolve deadlock consider order of transactions

SELECT * FROM accounts WHERE id = $1 LIMIT 1
+ FOR NO KEY UPDATE

# Isolation level
dirty read | read uncommitted 
non-repeatable read |read committed
phantom read | repeatable read
serialization anomaly | serializable

postgresql tx begin first when change isolation level.
postgresql not working level of dirty read | read uncommitted.
postgresql uses a dependencies checking mechanism
to detect potensial read phenomena and stop them by throwing error

# Github Actions | workflows
Golang Unit tests in external postgres service in github using .github/workflows/ci.yml

project folder -> 
    mkdir -p .github/workflows
    touch .github/workflows/ci.yml


# HTTP API

Gin.
the router field(package) is private so that Start function makes to access api package

* _ "github.com/lib/pq"

# Viper
golang packege, dealing with configuration file
ex) ENV, YAML ...

app.env
UPPERCASE=123

# Mock DB

make store to mock using interface.
interface cannot be pointer  

gomock makes fake DB Unit tests easily.
through the interface about DB service, mockgen makes Mock Service for Unit tests

# Test Multiple senarios
using t.Run()

# struct `` options -> nedd validator
binding:"oneof= " -> How to avoid hard-coding -> just 'currency'

import "github.com/go-playground/validator/v10"
var validCurreny validator.Func
  -> binding.Validator.Engine() (server.go)

# User Authentication and Authorization

# Update DB schema to previous version 

add foreign key and unique constraint
ref: 
    > many to one
    < one to many
    - one to one

make unique constraint
  indexes
  (field1, field2) [unique] 

Right way to migrate!
if you want to apply a new schema change,
create a new migration version.

command "migrate -verbose up 1 || down 1" -> choose version when migration.
so that can backup the db version

# handle DB errors for adding users migration

change owner -> user.Username(foreign key) to account test file.
command "make mock" regenerate
  -> added User interface to mock store file

Handle error code to the others
client accesss db constraits error code -> 403 
