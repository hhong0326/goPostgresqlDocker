MEMO

# DB Migration 

local to docker container
docker container to local


migrate create -ext sql -dir db/migration -seq init_schema
-seq means migrate version name.

migrate -path db/migration -database "postgres://root:secret@localhost:5432/simple_bank?sslmode=disable" -verbose up


brew install postgresql
brew install tableplus
brew install sqlc // sql to go 

# pq - A pure Go postgres driver for Go's database/sql package
go get github.com/lib/pq
go get github.com/stretchr/testify
                                  /require

# CRUD sqlc

move to root directory
 -> command "sqlc init"
 -> set sqlc.yaml file
 -> command "sqlc generate"


# Unit tests

When writing Unit tests,
Should make sure that they are independent from each other.
Why: hard to maintain if has hundred of tests that depends on each other.

# Transaction

DB Transaction

Why?
1. To provide a reliable and consistent unit of work, even in case of system failure.
2. To provide isolation between programs that access the database concurrently.

A: Atomicity
C: Consistency
I: Isolation
D: Durability

Closure is often used when want to get the result from a callback function.
the callback function itself doesn't know the exact type of the result it should return

# Caution when Database Transaction
concurrency carefully!
The best way that is run it with several concurrent go routines

# Update Account within Transaction
Require careful handing of concurrent transactions to avoid deadlock
database locking 

# TDD | test driven development
Tests first to make our current code breaks

# Deadlock postgresql
https://wiki.postgresql.org/wiki/Lock_Monitoring
Deadlock ocuurs because 2 concurrent transactions both need to wait for each other

can resolve deadlock consider order of transactions

SELECT * FROM accounts WHERE id = $1 LIMIT 1
+ FOR NO KEY UPDATE

# Isolation level
dirty read | read uncommitted 
non-repeatable read |read committed
phantom read | repeatable read
serialization anomaly | serializable

postgresql tx begin first when change isolation level.
postgresql not working level of dirty read | read uncommitted.
postgresql uses a dependencies checking mechanism
to detect potensial read phenomena and stop them by throwing error

# Github Actions | workflows
Golang Unit tests in external postgres service in github using .github/workflows/ci.yml

project folder -> 
    mkdir -p .github/workflows
    touch .github/workflows/ci.yml


# HTTP API

Gin.
the router field(package) is private so that Start function makes to access api package

* _ "github.com/lib/pq"

# Viper
golang packege, dealing with configuration file
ex) ENV, YAML ...

app.env
UPPERCASE=123

# Mock DB

make store to mock using interface.
interface cannot be pointer  

gomock makes fake DB Unit tests easily.
through the interface about DB service, mockgen makes Mock Service for Unit tests

# Test Multiple senarios
using t.Run()

# struct `` options -> nedd validator
binding:"oneof= " -> How to avoid hard-coding -> just 'currency'

import "github.com/go-playground/validator/v10"
var validCurreny validator.Func
  -> binding.Validator.Engine() (server.go)

# User Authentication and Authorization

# Update DB schema to previous version 

add foreign key and unique constraint
ref: 
    > many to one
    < one to many
    - one to one

make unique constraint
  indexes
  (field1, field2) [unique] 

Right way to migrate!
if you want to apply a new schema change,
create a new migration version.

command "migrate -verbose up 1 || down 1" -> choose version when migration.
so that can backup the db version

# handle DB errors for adding users migration

change owner -> user.Username(foreign key) to account test file.
command "make mock" regenerate
  -> added User interface to mock store file

Handle error code to the others
400 403 404
500

500 -> client accesss db constraits error code -> 403 

# bcrypt
make hashed password

# gomcok matcher

hash and salt makes pw test difficult
using matcher interface can make custom matcher

just implemented, unit test be stronger 

# JWT To PASETO

JSON Web Token
"Header.Payload.Signature"

JWT Signing Algorithms

1. Symmetric digital signature algorithm
- the same secret key is used to sign & verify Token
- For local use: internal services, where the secret key can be shared
- HS256, HS384, HS512
  - HS256 = HMAC + SHA256
  - HMAC: Hash-based Message Authentication Code
  - SHA: Secure Hash Algorithm
  - 256/384/512: number of output bits

2. Asymmetric disigtal signature algorithm
- The private key is used to sign Token
- The publi key is used to verify Token
- For public use: internal service signs token, but external service needs to verify it
- RS256, RS384, RS512 || PS256, PS384, PS512 || ES ...
  - RS256 = RSA PKCSv1.5 + SHA256 [PKCS: Public-Key cryptography Standards]
  - PS256 = RSA PSS + SHA256 [PSS: Probabilistic Signature Schema]
  - ES256 = ECDSA + SHA256 [ECDSA: Elliptic CUrve Digital Signature Algorithm]

Problem of JWT
  - weak Algorithms
  - Trivial Forgery(위조)


  PASETO
  Platform-Agnostic SEcurity TOkens

  - Stronger algorithm 
  (only need to select the version of PASETO)
  (Only 2 mosst recenbt PASETO versions are accepted)

  local -> Symmetric
  public -> Asymmetric
  
# Create JWT & PASETO token

interface 2 method

CreateToken
VerifyToken

go get github.com/google/uuid

Implementation of interface
  - Add Method for interface
  - Where the struct required function(method) of the interface
  - Implement method
  - Write func () MethodName() {}

Keyfunc is that receives the parsed but unverified token
verify its header, about siging algorithm matches

Test JWTToken function
both happy and error case

jwt to paseto
go get github.com/o1egl/paseto

PASETO CreaetToken -> paseto.Encrypt
PASETO VerifyToken -> paseto.Decrypt

